<!DOCTYPE html>
<html lang="en">
<head>
	<title>test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" href="./css/main.css" type="text/css">
	<script src="./js/libs/jquery.js"></script>
	<script src="./js/libs/TweenMax.min.js"></script>
</head>
<body>
	<div class="ww-content wwPos">
		<div class="ww-contTitle">
			<h3>文物解析</h3>
			<div class="ww-close"></div>
		</div>
		<div class="ww-text">
			<div class="ww-ContentP">
				<p>收藏于：河北博物院</p>
				<p>尺寸：高48厘米；重15.85kg</p>
				<p style="margin-bottom: 8px;">年代：西汉</p>
				<p class="wzjsP">长信宫灯，出土于中山靖王刘胜之妻窦绾墓，被誉为“中华第一灯”，是国家一级文物。宫灯主体为一通体鎏金跪坐宫女，上身平直着深衣，头梳发髻戴巾帼，左手执灯，右臂上扬，袖口罩于灯盘之上。神色温柔恭谨，动作自然优美。	
				</p>
				<p class="wzjsP">长信宫灯不仅具有审美价值还兼顾实用和科学环保功能，烟尘随手臂状烟道，进入灯体遇水过滤，形成烟灰，防止空气污染。灯罩和灯盘可左右移动调节照明强度和方向。
				</p>
			</div>
			<div class="mouseTip"><span></span></div>
		</div>
	</div>
	<div>
		<ul class="icon">
			<li>
				<span id="reset" class="svg">
					<svg class="svg-icon">
						<use xlink:href="#icon-i_reset">
							<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="icon" viewBox="0 0 1024 1024" id="icon-i_reset">
								<path d="M259.2 288l160 128L256 457.6zM512 512c-19.2 0-32-12.8-32-32v-96c0-16 12.8-32 32-32 16 0 32 12.8 32 32v96c0 19.2-12.8 32-32 32z" p-id="2083"></path>
								<path d="M489.6 467.2c9.6-16 28.8-19.2 44.8-9.6l86.4 54.4c16 9.6 19.2 28.8 9.6 44.8-9.6 16-28.8 19.2-44.8 9.6L499.2 512c-16-9.6-19.2-32-9.6-44.8z" p-id="2084"></path>
								<path d="M512 224c-134.4 0-243.2 102.4-256 233.6l67.2-16v-3.2C342.4 352 419.2 288 512 288c105.6 0 192 86.4 192 192s-86.4 192-192 192c-73.6 0-137.6-41.6-169.6-102.4l-64 12.8C316.8 672 406.4 736 512 736c140.8 0 256-115.2 256-256s-115.2-256-256-256z" p-id="2085"></path>
							</svg>
						</use>
					</svg>
				</span>
			</li>
			<li>
				<span id="rotate" class="svg">
					<svg class="svg-icon">
						<use xlink:href="#icon-i_rotate">
							<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="icon" viewBox="0 0 1024 1024" id="icon-i_rotate">
								<path d="M288 416h64v32H288v-32z m64 0h32v160h-32v-160z m-64 128h64v32H288v-32z m0-64h64v32H288v-32z m128-32h32v128h-32v-128z m32 32h64v32h-64v-32z m32 32h32v64h-32v-64z m-32 32h32v32h-32v-32z m-32-128h96v32h-96v-32z m128 32h32v128h-32v-128z m0-32h96v32h-96v-32z m64 32h32v128h-32v-128z m-32 96h32v32h-32v-32z m95.456-128H736v64h-64.544v-64z" p-id="2678"></path>
								<path d="M291.2 304a602.528 602.528 0 0 1 228.736-64 417.504 417.504 0 0 1 208 64l-41.6 42.656A281.792 281.792 0 0 0 520 304a451.488 451.488 0 0 0-208 64 91.296 91.296 0 0 1-24-32 45.44 45.44 0 0 1 3.2-32z" p-id="2679"></path>
								<path d="M608 384l160-128v128h-160z" p-id="2680"></path><path d="M748.8 688a602.528 602.528 0 0 1-228.736 64 417.472 417.472 0 0 1-208-64l41.6-42.656a281.792 281.792 0 0 0 166.4 42.656 451.552 451.552 0 0 0 208-64 36.96 36.96 0 0 1 24.032 32 63.232 63.232 0 0 1-3.296 32z" p-id="2681"></path><path d="M448 608l-159.744 128.32L288 608h160z" p-id="2682"></path>
							</svg>
						</use>
					</svg>
				</span>
			</li>
			<li>
				<span id="size" class="svg">
					<svg class="svg-icon">
						<use xlink:href="#icon-i_size">
							<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="icon" viewBox="0 0 1024 1024" id="icon-i_size">
								<path d="M256 512h64v256H256v-256z m64 192h384v64H320v-64z m384-192h64v256h-64v-256zM256 448h512v64H256v-64z" p-id="2201"></path>
								<path d="M362.496 474.496h64v107.008h-64v-107.008z" p-id="2202"></path>
								<path d="M485.504 474.496h64V624h-64v-149.504z" p-id="2203"></path>
								<path d="M592 453.504h64v128h-64v-128z" p-id="2204"></path>
								<path d="M256 256h64v128H256z" p-id="2205"></path>
								<path d="M704 256h64v128h-64z" p-id="2206"></path>
								<path d="M298.496 282.496h427.008v64H298.496v-64z" p-id="2207"></path>
							</svg>
						</use>
					</svg>
				</span>
			</li>
			<li>
				<span id="download" class="svg">
					<img src="./image/download.png" width="17" height="17"/>
				</span>
			</li>
		</ul>
	</div>

	<div class="confirm">
		<div class="dialog">
			<div class="dialog-header">下载需要41MB，是否下载？</div>
			<div class="dialog-footer">
				<input type="button" class="btn" id="confirm" value="确定">
				<input type="button" class="btn ml50" id="cancel" value="取消">
			</div>
		</div>
	</div>
	<div class="annotation"></div>

	<script>
		var html = '<div class="loading">' + 
		'<div class="loading_t" style="margin-top: ' + (window.innerHeight / 2 - 60) + 'px;"><img src="./image/logo.png" width="183" height="40" ></div>' + 
		'<div class="progressBar">' + 
			'<div></div>' + 
		'</div>' + 
		'<div class="loading_percent">0%</div>' + 
		'</div>';

		document.write(html);
	</script>

	<script type="module">
		import * as THREE from './js/three.module.js';
		import Stats from './js/libs/stats.module.js';
		import { GUI } from './js/libs/dat.gui.module.js';
		import { OrbitControls } from './js/controls/OrbitControls.js';
		import { GLTFLoader } from './js/loaders/GLTFLoader.js';
		import { RGBELoader } from './js/loaders/RGBELoader.js';
		import { RoughnessMipmapper } from './js/loaders/RoughnessMipmapper.js';

		var camera, scene, renderer, raycaster, stats, controls;
		var clock = new THREE.Clock();
		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2();

		var groupArray = [];
		var initPosition = new THREE.Vector3(-146, 0, 0);

		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2();

		var meshArray = []; // 网格数组
		var modelObject;

		var spriteVector = new THREE.Vector3(-26, 12.5, -6.5);
		var sphere;
		var annotationShow = false;

		var positionY = -128;
		var index = 0;
		var annotation = $('.annotation');

		// 点击热点后, 相机移动到如下位置
		var cameraPosition4Sprite = new THREE.Vector3(-75, 25, -23);

		init();
		animate();

		//1.场景
		function initScene() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x6f6f6f );

			window.scene = scene;
		}

		//2.透视相机
		function initCamera() {
			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 10, 2000);
			camera.position.copy(initPosition);

			window.camera = camera;
		}

		//3.渲染器
		function initRender() {
			raycaster = new THREE.Raycaster();
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;

            renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			document.body.appendChild(renderer.domElement);
		}

		//4.事件
		function initEvent() {
			window.addEventListener('resize', onWindowResize, false);

			$('#rotate').click(function(){
				controls.autoRotate = !controls.autoRotate;

				if (controls.autoRotate) {
					$(this).addClass('active');
				} else {
					$(this).removeClass('active');
				}
			});

			$('#reset').click(function(){
				TweenMax.to( camera.position, 1, { x: initPosition.x, y: initPosition.y, z: initPosition.z } );
			});

			$('#size').click(function(){
				if ($(this).hasClass('active')) {
					$(this).removeClass('active');
				} else {
					$(this).addClass('active');
				}

				var opacity = $(this).hasClass('active') ? 1 : 0;
				for (var i = 0; i < groupArray.length; i++) {
					var group = groupArray[i];
					for (var j = 0; j < group.children.length; j++) {
						var mesh = group.children[j];
						TweenMax.to( mesh.material, 1, { opacity: opacity, ease: Power2.easeInOut } );
					}
				}
			});

			$('#download').click(function(){
				if ($('#download').data('disabled') === true) {
					return;
				}
				$('.confirm').show();
				$('.dialog').css('marginTop', (window.innerHeight / 2 - 60) + 'px');
			});

			$('#confirm').click(function(){
				$('.confirm').hide();
				$('.loading').show();
				$('.ww-content').hide().height(0);
				annotation.hide();

				var progressBar = $('.progressBar div');
				progressBar.width(0);

				if ($('#size').hasClass('active')) {
					$('#size').removeClass('active');
					for (var i = 0; i < groupArray.length; i++) {
						var group = groupArray[i];
						for (var j = 0; j < group.children.length; j++) {
							var mesh = group.children[j];
							mesh.material.opacity = 0;
						}
					}
				}

				modelObject.visible = false;
				loadModel('high.glb', 0.76, new THREE.Vector3(-2, -34, 9.1), 0.1);
				$('#download').data('disabled', true).parent().css('cursor', 'not-allowed');
			});

			$('#cancel').click(function(){
				$('.confirm').hide();
			});

			annotation.click(function(){
				$('.ww-content').show().height(400);

				// 移动相机到指定位置
				TweenMax.to( camera.position, 1, { x: cameraPosition4Sprite.x, y: cameraPosition4Sprite.y, z: cameraPosition4Sprite.z } );
			});

			$('.ww-close').click(function(){
				$('.ww-content').height(0);
			});
		}

		//5.控制
		function initControls() {
			controls = new OrbitControls(camera, renderer.domElement);
			controls.minDistance = 50;
            controls.maxDistance = 200;
			controls.enableDamping = true;
			controls.dampingFactor = 0.2;
            controls.enablePan = false;
			controls.update();
		}

		//6.光源
		function initLight(array, offset) {
			//环境光
			var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
			scene.add(ambientLight);

			//平行光1，设置光的颜色，强度，位置，是否投射阴影，阴影相机的各种参数
            var dirLight = new THREE.DirectionalLight( 0xffffff, 0.2 );
            dirLight.position.set( 80, 100, 80 );
            dirLight.castShadow = true;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.left = - 100;
            dirLight.shadow.camera.top	= 100;
            dirLight.shadow.camera.bottom = - 100;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;

            scene.add( dirLight );

            // window.dirLight = dirLight;

            //光源辅助对象
            // var helper = new THREE.DirectionalLightHelper( dirLight, 5 );
            // scene.add( helper );

            //平行光2
            var dirLight2 = dirLight.clone();
            dirLight2.intensity = 1;
            dirLight2.position.set(-80, 100, 80);
            scene.add(dirLight2);

            // var helper = new THREE.DirectionalLightHelper( dirLight2, 5 );
            // scene.add( helper );

            var dirLight3 = dirLight.clone();
            dirLight3.intensity = 1;
            dirLight3.position.set(-80, -100, -80);
            scene.add(dirLight3);

            // var helper = new THREE.DirectionalLightHelper( dirLight3, 5 );
            // scene.add( helper );

            var dirLight4 = dirLight.clone();
            dirLight4.intensity = 1;
            dirLight4.position.set(80, -100, -80);
            scene.add(dirLight4);

            var dirLight5 = dirLight.clone();
            dirLight4.intensity = 1;
            dirLight5.position.set(80, -100, 80);
            scene.add(dirLight5);

            var dirLight6 = dirLight.clone();
            dirLight4.intensity = 1;
            dirLight6.position.set(-80, 100, -80);
            scene.add(dirLight6);
            // var helper = new THREE.DirectionalLightHelper( dirLight4, 5 );
            // scene.add( helper );
		}

		//7.其它
		function initOther() {
			//x, y, z轴辅助器
			var axes = new THREE.AxesHelper(500);
			// axes.position.set(100, 100, 100);
			// scene.add(axes);

			//性能检查Stats， 可以查看当前帧数
			stats = new Stats();
			//document.body.appendChild( stats.dom );

			loadModel('scene.glb', 0.1, new THREE.Vector3(0, 0, 0));

			sphere = new THREE.Mesh( new THREE.SphereBufferGeometry( 0.5, 32, 32 ), new THREE.MeshBasicMaterial( {color: 0xffffff, transparent: true, opacity: 0} ) );
			sphere.name = 'sphere';
			sphere.position.copy(spriteVector);
			scene.add( sphere );

			meshArray.push(sphere);
		}

		function loadModel(name, scale, position, initScale = 1) {
			new RGBELoader()
				.setDataType( THREE.UnsignedByteType )
				.setPath( 'model/' )
				.load( '3.hdr', function ( texture ) {

					var pmremGenerator = new THREE.PMREMGenerator( renderer );
					pmremGenerator.compileEquirectangularShader();
					var envMap = pmremGenerator.fromEquirectangular( texture ).texture;

					// scene.background = envMap;
					// scene.environment = envMap;

					texture.dispose();
					pmremGenerator.dispose();

					render();

					var progressBar = $('.progressBar div');
					var loadingPercent = $('.loading_percent');
					// use of RoughnessMipmapper is optional
					var roughnessMipmapper = new RoughnessMipmapper( renderer );

					var loader = new GLTFLoader().setPath( './model/' );
					loader.load( name, function ( gltf ) {
						$('.loading').hide();

						var object = gltf.scene;
						object.traverse( function ( child ) {
							if ( child.isMesh ) {
								roughnessMipmapper.generateMipmaps( child.material );

								child.material.envMap = envMap;

								meshArray.push(child);
							}
						} );

						new THREE.Box3().setFromObject(object).getCenter(object.position).multiplyScalar(-1);
						object.position.copy(position);
						scene.add(object);

						object.scale.set(initScale, initScale, initScale);

						modelObject = object;
						window.modelObject = modelObject;

						TweenMax.to( object.scale, 2, { x: scale, y: scale, z: scale, ease: Power2.easeInOut } );
						TweenMax.to( object.rotation, 1.5, { x: 0, y: Math.PI / 2, z: 0, ease: Power2.easeInOut, onComplete: function() {
							annotationShow = true;
						} } );
						
						roughnessMipmapper.dispose();
						render();

						var box3 = new THREE.Box3().setFromObject(object);
						console.log(box3);

						if (groupArray.length === 0) {
							initSize(box3, scale, object.position, false);
						}
						
					}, function(xhr) {
						// console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
						// console.log(( xhr.loaded / xhr.total * 100 ).toFixed(2));

						loadingPercent.text(( xhr.loaded / xhr.total * 100 ) + '%');
						progressBar.width(Math.round( xhr.loaded / xhr.total * 220 ));
					} );
				} );
		}

		function getText(font, message) {
			var matLite = new THREE.MeshBasicMaterial( {
				color: 0x000000,
				side: THREE.DoubleSide,
				transparent: true,
				opacity: 0
			} );

			var shapes = font.generateShapes( message, 5 );

			var geometry = new THREE.ShapeBufferGeometry( shapes );
			geometry.computeBoundingBox();

			var xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
			geometry.translate( xMid, 0, 0 );

			var text = new THREE.Mesh( geometry, matLite );
			text.position.y = 5;

			return text;
		}

		function getSizeMesh(end) {
			var w = 0.6;
			var h = 6;
			var start = new THREE.Vector2(0, 0);
			var end = new THREE.Vector2(end, 0);

			var shape = new THREE.Shape()
				.moveTo( start.x, start.y )
				.lineTo( start.x, start.y + h )
				.lineTo( end.x, end.y + h )
				.lineTo( end.x, end.y )
				.lineTo( end.x - w, end.y )
				.lineTo( end.x - w, end.y + h - w )
				.lineTo( start.x + w, start.y + h - w )
				.lineTo( start.x + w, start.y )
				.lineTo( start.x, start.y );
			var geometry = new THREE.ShapeBufferGeometry( shape );
			geometry.center();

			return new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide, transparent: true, opacity: 0 } ) );
		}

		function initSize(boundingBox, scale, position, isFront) {
			var offset = 10;

			var width = scale * (boundingBox.max.x - boundingBox.min.x);
			var height = scale * (boundingBox.max.y - boundingBox.min.y);
			var depth = scale * (boundingBox.max.z - boundingBox.min.z);

			var group1 = new THREE.Group();
			group1.add(getSizeMesh(width));

			var group2 = new THREE.Group();
			group2.add(getSizeMesh(height));

			var group3 = new THREE.Group();
			group3.add(getSizeMesh(depth));

			var loader = new THREE.FontLoader();
			loader.load( 'font/helvetiker_regular.typeface.json', function ( font ) {
				group1.add( getText(font, '32.00cm') );
				group2.add( getText(font, '40.00cm') );
				group3.add( getText(font, '38.00cm') );

				if (isFront) {
					group1.position.set(position.x, position.y + height / 2 + offset, position.z);
				} else {
					group1.position.set(position.x, position.y - height / 2 - offset, position.z + depth / 2 + offset);
					group1.children[0].rotation.z = Math.PI;
				}
				
				scene.add(group1);
				groupArray.push(group1);

				if (isFront) {
					group2.rotation.set(0, 0, Math.PI / 2);
					group2.position.set(position.x - width / 2 - offset, position.y, position.z);
				} else {
					group2.rotation.set(0, -Math.PI / 2, Math.PI / 2);
					group2.position.set(position.x, position.y, position.z - depth / 2 - offset);
				}

				scene.add(group2);
				groupArray.push(group2);

				if (isFront) {
					group3.position.set(position.x + width / 2 + offset, position.y - height / 2, position.z);
					group3.rotation.y = Math.PI / 2;
					group3.children[0].rotation.x = Math.PI;
				} else {
					group3.position.set(position.x, position.y + height / 2 + offset, position.z);
					group3.rotation.y = -Math.PI / 2;
				}
				scene.add(group3);
				groupArray.push(group3);
			});
		}

		// 初始函数，初始化各种对象
		function init() {
			initScene();
			initCamera();
			initRender();
			initEvent();
			initControls();
			initLight();
			initOther();
		}

		// 窗口缩放时自适应屏幕
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function setupMouseCoords(event) {
			var x, y;
			if (event.changedTouches) {
				x = event.changedTouches[0].pageX;
				y = event.changedTouches[0].pageY;
			} else {
				x = event.clientX;
				y = event.clientY;
			}

			mouse.x = (x / window.innerWidth) * 2 - 1;
			mouse.y = -(y / window.innerHeight) * 2 + 1;
		}

		function world2Screen(x, y, z) {
			let worldVector = new THREE.Vector3(x, y, z);
			let vector = worldVector.project(camera);

			let halfWidth = window.innerWidth / 2;
			let halfHeight = window.innerHeight / 2;
			
			let result = {
				x: Math.round(vector.x * halfWidth + halfWidth),
				y: Math.round(-vector.y * halfHeight + halfHeight)
			};
			
			return result;
		}

		function updateScreenPosition() {
			index++;
			annotation.css('background-position', '0px ' + (Math.round(index / 3) * positionY) + 'px');
			
			if (index > 75) {
				index = 0;
			}

			var vector = spriteVector.clone();
			vector.project(camera);

			vector.x = Math.round((0.5 + vector.x / 2) * (window.innerWidth / window.devicePixelRatio));
			vector.y = Math.round((0.5 - vector.y / 2) * (window.innerHeight / window.devicePixelRatio));

			annotation.css({top: (vector.y - 64) + "px", left: (vector.x - 64) + "px"});

			var vector2 = world2Screen(spriteVector.x, spriteVector.y, spriteVector.z);
			setupMouseCoords({ clientX: vector2.x, clientY: vector2.y });

			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(meshArray, true);
			if (intersects.length) {
				if (intersects[0].object.name === 'sphere') {
					annotationShow && annotation.show();
				} else {
					annotation.hide();
				}
			}
		}

		function animate() {
			render();

			updateScreenPosition();

			requestAnimationFrame(animate); //循环执行animate函数
		}

		function render() {
			controls.update();
			stats.update();

			renderer.clear();
			renderer.render(scene, camera);
		}
	</script>
</body>
</html>